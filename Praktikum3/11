
1.1)
a)
trace(P [] Q) = trace(P) U trace(P) // 6.14
trace(P /\ Q) = trace(P) U trace(P) // 6.16
P [] Q = Q /\ P

b)
traces (Stop) = {⟨⟩} // 6.3
Prefix-Abgeschlossenheit
T1 : ⟨⟩ ∈ traces(P) // 6.1
trace(P) U {⟨⟩} = trace(P) // 6.53
P /\ Stop = P

c)
// 6.32:
traces(P1 |A| P2) =
{tr ∈ TRACES | ∃ tr1, tr2 •
tr1 ∈ traces(P1)
∧ tr2 ∈ traces(P2)
∧ tr synchA tr1, tr2}
wenn gilt:
P1 = P2 = SKIP
traces(Skip) = {⟨⟩ , ⟨tick⟩} // 6.4
dann gilt auch:
synchA ({⟨⟩ , ⟨tick⟩}) = {⟨⟩ , ⟨tick⟩} // 6.39 -> 6.36 (<>) und 6.39 -> 6.37 (<tick>)
// Die Menge A ist beliebig, da ohne nur die die head und tails
// von tr1 und tr2 in 6.39 betrachtet werden